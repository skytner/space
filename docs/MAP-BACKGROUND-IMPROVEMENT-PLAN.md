# План работ: улучшение фона карты (звёздное поле)

Цель: вывести визуал карты на уровень профессиональных симуляций (NASA Eyes): детерминированность без артефактов, реалистичные цвета и распределение, возможность подмешивать реальные данные.

---

## Проблемы текущего подхода

- **mulberry32** — плохая статистическая распределённость: ~⅓ чисел по сути недостижима → на больших картах видны «пустоты» и кластеры.
- **Фиксированный сид (42)** — один и тот же паттерн на всей карте; при тайлинге возможны повторяющиеся участки.
- **Белые звёзды** — нет глубины, всё выглядит как шум.
- **Нет кэширования тайлов** — при pan/инерции пересчёт каждый кадр → возможные лаги.

---

## 1. PRNG и сидирование

### 1.1 Заменить mulberry32 на splitmix32

- **Зачем:** более качественное 32-битное распределение, меньше артефактов.
- **Где:** общий RNG для процедурной генерации (звёздная пыль, мелкие звёзды).

```js
// splitmix32 — качественный PRNG
function splitmix32(a) {
  return function() {
    a |= 0; a = a + 0x9e3779b9 | 0;
    let t = a ^ a >>> 16;
    t = Math.imul(t, 0x21f0aaad);
    t = t ^ t >>> 15;
    t = Math.imul(t, 0x735a2d97);
    return ((t = t ^ t >>> 15) >>> 0) / 4294967296;
  };
}
```

### 1.2 Сид из координат тайла: xmur3

- **Зачем:** каждый тайл `(i, j)` получает свой сид из строки координат → уникальный, но детерминированный участок; бесшовный и неповторяющийся пан при бесконечной карте.
- **Где:** при генерации звёзд для тайла вызывать `xmur3(\`${i},${j}\`)()` (или аналог) и передавать полученный сид в splitmix32.

```js
// xmur3 — хеш строки в 32-битный сид
function xmur3(str) {
  for (var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353), h = h << 13 | h >>> 19;
  return function() {
    h = Math.imul(h ^ h >>> 16, 2246822507), h = Math.imul(h ^ h >>> 13, 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
```

**Результат:** один RNG (splitmix32) + сид на тайл через xmur3; константу типа `42` не использовать как единственный сид.

---

## 2. Цвета звёзд: OBAFGKM (спектральные типы)

- **Сейчас:** по сути белые точки.
- **Цель:** глубина за счёт холодных и тёплых оттенков по спектральному классу.

**Маппинг (hex):**

| Тип | Название      | Цвет   | Hex       |
|-----|---------------|--------|-----------|
| O   | Blue          | Голубой| `#9bb0ff` |
| B   | Blue-White    |        | `#aabfff` |
| A   | White         | Белый  | `#cad7ff` |
| F   | Yellow-White  |        | `#f8f7ff` |
| G   | Yellow        | Жёлтый | `#fff4ea` |
| K   | Orange        | Оранжевый | `#ffd2a1` |
| M   | Red           | Красный| `#ffcc6f` |

- **Процедурные звёзды:** назначать тип по яркости/рандому (например, яркие реже, тусклые чаще) и брать цвет из таблицы.
- **Hero stars (API):** использовать `spectralType` из ответа и тот же маппинг.

---

## 3. Распределение яркости (density function)

- **Цель:** как в реальности — слабых звёзд намного больше, чем ярких.
- **Реализация:** степенное распределение (power-law): вероятность яркости ∝ magnitude или аналогичная функция; меньше ярких, больше тусклых.
- **Где:** при генерации процедурных звёзд — сначала определять «класс яркости»/магнитуду по RNG с весами, затем размер/цвет/тип.

---

## 4. Визуальные эффекты

### 4.1 Мерцание (scintillation)

- Синусоида по времени с **индивидуальной фазой** на каждую звезду (phase offset из RNG).
- Опционально: только для звёзд выше порога яркости.

### 4.2 Мягкое свечение ярких звёзд

- Вместо одного `fillStyle` + `arc` — **радиальный градиент** от яркого центра к полупрозрачному краю.
- Применять к звёздам выше заданного порога яркости/размера.

---

## 5. Оптимизация: кэширование тайлов (OffscreenCanvas)

- **Проблема:** при pan каждый кадр перерисовываются все видимые звёзды → лишние вычисления и возможные лаги при инерции.
- **Решение:** для каждого тайла `(i, j)` один раз сгенерировать звёзды и отрисовать в **OffscreenCanvas**; при рендере кадра просто делать `drawImage(cachedTile, ...)` в основной контекст.
- **Инвалидация:** только при смене параметров генерации (сид, плотность, спектры) или при первом появлении тайла; при обычном pan — только сдвиг уже отрисованных тайлов.

---

## 6. Реальные данные vs процедурка (гибрид)

### 6.1 Концепция

- **Hero stars:** небольшой набор ярких звёзд (например, из HYG: magnitude < 6.5, порядка 5–9k штук) — дают узнаваемый рисунок созвездий.
- **Процедурка:** «звёздная пыль» и мелкие звёзды заполняют фон и пустоты; генерация через splitmix32 + xmur3 по тайлам.

### 6.2 Бэкенд (перспектива)

- Запрос к БД (HYG / Hipparcos, Yale, Gliese): только hero stars (магнитуда, координаты X/Y/Z, спектральный тип).
- Отдавать JSON с полями, удобными для фронта (например, уже в экранных/парсековых единицах или явная проекция).

### 6.3 Фронт: API и MSW

- **Хук:** `useHeroStars()` (или аналог) — запрос к API, ответ: массив объектов вида `{ x, y, z?, magnitude, spectralType }`.
- **Пока бэка нет:** мок через **MSW** — handler возвращает JSON с подмножеством «ярчайших» звёзд (пара сотен для старта).
- **Формат мока:** координаты X/Y/Z в выбранном пространстве (например, парсеки или уже спроецированные в 2D для карты); `spectralType` из OBAFGKM для подстановки в цветовую таблицу.

Пример скелета MSW handler (идея):

```js
// Пример: handlers возвращают hero stars
import { http, HttpResponse } from 'msw';

export const handlers = [
  http.get('/api/stars/heroes', () => {
    return HttpResponse.json({
      stars: [
        { id: '1', x: 0, y: 0, z: 0, magnitude: 1.5, spectralType: 'G' },
        // ... подмножество HYG
      ],
    });
  }),
];
```

- **Рендер:** hero stars рисуются поверх/вместе с процедурным слоем; для них те же OBAFGKM цвета и при желании — градиент и мерцание.

---

## 7. Порядок работ (roadmap)

| # | Задача | Зависимости |
|---|--------|-------------|
| 1 | Вынести **xmur3** и **splitmix32** в shared/utils (или map/utils), заменить mulberry32 в генерации звёзд | — |
| 2 | Сидирование по тайлу: сид = `xmur3(\`${i},${j}\`)()` для каждого тайла (i, j) | 1 |
| 3 | Ввести **OBAFGKM** палитру и назначать процедурным звёздам тип/цвет по яркости | 1 |
| 4 | **Power-law** распределение яркости при генерации (больше слабых, меньше ярких) | 1, 3 |
| 5 | **Мерцание:** синус по времени + фаза на звезду | 1 |
| 6 | **Радиальный градиент** для ярких звёзд вместо жёсткого круга | 3 |
| 7 | **OffscreenCanvas:** кэш отрисованного тайла по (i, j), при pan — drawImage кэша | 1, 2 |
| 8 | **API + хук** для hero stars (тип ответа, URL, хук useHeroStars) | — |
| 9 | **MSW:** handler для hero stars, JSON с x, y, z, magnitude, spectralType | 8 |
| 10 | Рисовать hero stars на карте (те же цвета OBAFGKM, при желании градиент/мерцание) | 3, 8, 9 |

---

## 8. Критерии готовности

- Нет визуальных «пустот» и явных кластеров при долгом pan по карте.
- Звёзды разного цвета (холодные/тёплые) по спектральному типу.
- Ярких звёзд меньше, тусклых больше (ощутимо по картинке).
- При быстром движении (инерция) нет лагов за счёт кэша тайлов.
- При включённом MSW на экране видны hero stars из мока с корректными цветами.

---

## 9. Промпт для UI-агента (референс)

Ниже — сжатый промпт, на основе которого можно поручить агенту переписать/дописать CanvasMap:

```text
Rewrite the CanvasMap component to implement a deterministic, tile-based infinite starfield with high visual fidelity.

PRNG & Seeding: Replace mulberry32 with splitmix32. Implement xmur3 to generate a unique seed for each tile based on its coordinates (i, j). This ensures seamless, non-repeating, but deterministic infinite panning.

Celestial Colors: Implement a color mapping based on the OBAFGKM spectral sequence. Use these hex codes:
O #9bb0ff, B #aabfff, A #cad7ff, F #f8f7ff, G #fff4ea, K #ffd2a1, M #ffcc6f.

Distribution: Implement a density function so that fainter stars are significantly more numerous than bright ones (power-law distribution).

Visual Effects:
- Add a subtle flicker (scintillation) to stars using a sine wave with a per-star random phase offset.
- Use radial gradients for the brightest stars to simulate a soft glow instead of hard circles.

Optimization: Use an OffscreenCanvas to cache rendered tiles. On pan, draw cached tile images to the main context instead of recalculating stars every frame.

Data Integration: Add a hook to fetch "hero stars" from an API (JSON with x, y, magnitude, spectralType). Mock this API using MSW with a subset of HYG-style data.
```

---

Итог: в одном документе — проблемы, PRNG/сиды, цвета, распределение, эффекты, кэш тайлов, гибрид с hero stars и MSW, порядок работ и промпт для агента.
