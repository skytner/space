# Ревью: packages/sdk (http-client)

**Scope:** HTTP-клиент с таймаутом, отменой дубликатов по method+url, кастомными сообщениями об ошибках, onError-колбэком.

---

## Что хорошо

- Понятное API: `create(config)`, `get/post/put/patch/delete`, опции `headers` и `signal`.
- Отмена предыдущего запроса при повторном вызове с тем же method+url (inFlight + AbortController).
- Таймаут через `setTimeout` + abort.
- HttpError с status, body и сообщением; нормализация ошибок (handleHttpError) для onError и UI.
- Гибкие сообщения по кодам (errorMessages) и дефолты в константах.
- Корректная очистка таймера и inFlight в try и в catch.

---

## Важно

### 1. Цикл зависимостей: types/request → handlers/onError → types/errors

**Файлы:** `types/request.ts` импортирует `NormalizedError` из `../handlers/onError`, а `handlers/onError` импортирует типы из `../types/errors`. Получается цепочка types → handlers → types.

В бандле это может собраться нормально, но при строгом порядке загрузки или в части окружений возможны глюки. Плюс типы логичнее держать в слое типов, а не в handlers.

**Рекомендация:** перенести тип `NormalizedError` в слой типов, например в `types/errors.ts` или в отдельный `types/normalizedError.ts`, и импортировать его и в `request.ts`, и в `onError.ts`. Так цикл разрывается, структура понятнее.

---

### 2. Ключ inFlight не учитывает body и headers

**Файл:** `http-client/client.ts`, ключ `key = \`${method}:${fullURL}\``.

Один и тот же ключ используется для всех запросов с одинаковыми method и url. Два последовательных POST на один url с разным телом тела приведут к отмене первого запросом второго.

Если цель — «один активный запрос на ресурс (method+url)», текущее поведение ок. Если нужно различать запросы по телу или заголовкам (например, разный контент), ключ стоит расширить (например, хэш body + опционально заголовки) или не класть в inFlight запросы с переданным внешним `signal`.

---

## Рекомендации

### 3. Неизвестные HTTP-коды

**Файл:** `http-client/functions/getMessageForError.ts`.

Для кодов, которых нет в `ERROR_STATUS_TO_KEY` и `ERROR_DEFAULT_MESSAGES` (например 502, 418), функция возвращает `undefined`. В `HttpError` тогда подставляется `HTTP ${status}` — этого достаточно, но сообщение для пользователя может быть грубоватым.

**Опционально:** добавить общий fallback, например:  
`return custom ?? fallback ?? \`Ошибка запроса (${status})\`;`

---

### 4. package.json

В `packages/sdk` не найден `package.json`. Если пакет подключается из других workspace (например, `@repo/sdk`), нужны `name`, `main`/`types`/`exports`, при необходимости `peerDependencies` (например, без react/fetch — только типы и среда с fetch). Если пока используете только через относительные пути — можно оставить как есть и зафиксировать в описании репо.

---

## Мелочи

- **client.ts:** в `setTimeout(() => controller!.abort(), ...)` после только что созданного `AbortController()` non-null assertion оправдан, но при рефакторе можно завести локальную переменную и использовать её без `!`.
- **onError.ts:** хардкод сообщений на русском («Запрос отменён», «Ошибка сети», «Неизвестная ошибка») — если позже понадобится i18n, их стоит вынести в константы или конфиг.

---

## Итог

| Приоритет | Действие |
|-----------|----------|
| **Желательно** | П.1 — вынести `NormalizedError` в types и убрать цикл. |
| **По смыслу фичи** | П.2 — либо оставить текущую семантику ключа (один запрос на method+url), либо расширить ключ / не использовать inFlight при внешнем signal. |
| **По желанию** | П.3 — fallback для неизвестных кодов; п.4 — добавить package.json при публичном пакете; мелочи. |

Код рабочий и аккуратный; после правки цикла (п.1) можно смело коммитить.
